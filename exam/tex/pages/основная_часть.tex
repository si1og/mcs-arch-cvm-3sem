% Экзаменационные вопросы по вычислительной технике
% Для включения: \input{exam_full.tex}

\subsubsection*{Вопрос 1. В каком году была построена первая вычислительная машина?}

Первая электронная вычислительная машина ENIAC была построена в \textbf{1946 году} в США (Пенсильванский университет). Она содержала около 18 000 электронных ламп, весила 30 тонн и выполняла около 5000 операций сложения в секунду.

\subsubsection*{Вопрос 2. В каком году и кем была построена первая отечественная вычислительная машина?}

Первая отечественная ЭВМ — МЭСМ (Малая Электронная Счётная Машина) — была создана в \textbf{1950 году} под руководством академика \textbf{Сергея Алексеевича Лебедева} в Киеве. В 1952 году под его же руководством была создана БЭСМ — на тот момент самая быстрая ЭВМ в Европе.

\subsubsection*{Вопрос 3. Нарисуйте простейшую структурную схему вычислительной машины.}

Классическая архитектура фон Неймана:
\begin{verbatim}
+-------------+      +-------------+      +------------------+
|  Процессор  |<---->|   Память    |<---->| Устройства ввода-|
|    (CPU)    |      | (RAM, ROM)  |      |      вывода      |
+-------------+      +-------------+      +------------------+
       ^                   ^                      ^
       |___________________|______________________|
                    Системная шина
\end{verbatim}

Основные принципы: программа и данные хранятся в общей памяти, команды выполняются последовательно, всё представлено в двоичном коде.

\subsubsection*{Вопрос 4. Машина с радиальной архитектурой — это...}

Архитектура, в которой каждое периферийное устройство подключается к процессору по \textbf{отдельной, выделенной линии связи}. Преимущество: высокая пропускная способность, нет конфликтов за общую шину. Недостаток: сложность, дороговизна, плохая масштабируемость.

\subsubsection*{Вопрос 5. Магистраль — это...}

\textbf{Магистраль (системная шина)} — совокупность линий, обеспечивающих передачу информации между компонентами ЭВМ. Состоит из трёх частей:
\begin{itemize}
\item \textbf{Шина данных} — передача данных (двунаправленная)
\item \textbf{Шина адреса} — передача адресов (однонаправленная от CPU)
\item \textbf{Шина управления} — сигналы чтения, записи, прерываний
\end{itemize}

\subsubsection*{Вопрос 6. Северный и южный мосты. Назначение.}

\textbf{Северный мост (MCH — Memory Controller Hub):}
\begin{itemize}
\item Связывает процессор с быстрыми устройствами
\item Управляет оперативной памятью
\item Обеспечивает связь с видеокартой (AGP, PCI-E x16)
\end{itemize}

\textbf{Южный мост (ICH — I/O Controller Hub):}
\begin{itemize}
\item Связывает северный мост с медленными устройствами
\item Управляет USB, SATA, PCI, аудио, сетью
\item Содержит контроллер прерываний, BIOS
\end{itemize}

\subsubsection*{Вопрос 7. Отличительные особенности Hub-архитектуры.}

Hub-архитектура заменяет общую шину на \textbf{выделенные каналы (point-to-point)} между компонентами. Каждая подсистема имеет собственный канал к хабу. Преимущества: устранение конфликтов за шину, увеличение пропускной способности, возможность параллельной работы устройств.

\subsubsection*{Вопрос 8. Пропускная способность шины — это...}

Максимальный объём данных, передаваемый по шине за единицу времени. Формула:
\[
\text{ПС} = \frac{\text{Разрядность (бит)}}{8} \times \text{Частота (Гц)} \times \text{Передач за такт}
\]
Пример: 64 бита, 100 МГц, DDR (2 передачи): $\frac{64}{8} \times 100 \times 10^6 \times 2 = 1600$ МБ/с.

\subsubsection*{Вопрос 9. Контроль по чётности, привести пример.}

Метод обнаружения ошибок: к данным добавляется бит так, чтобы общее число единиц было чётным (even parity) или нечётным (odd parity).

Пример (even parity):
\begin{itemize}
\item Данные: \texttt{1010110} (4 единицы — чётное)
\item Бит чётности: \texttt{0}
\item Передаётся: \texttt{10101100}
\end{itemize}
Ограничение: обнаруживает только нечётное число ошибок, не исправляет.

\subsubsection*{Вопрос 10. Шинный цикл состоит из... (Нарисовать)}

Шинный цикл — последовательность действий для одной операции обмена:
\begin{verbatim}
   T1        T2        T3        T4        Tw
   |         |         |         |         |
Выставле-  Подго-   Передача  Заверше-   Такты
ние адреса товка    данных    ние цикла  ожидания
\end{verbatim}
\begin{itemize}
\item \textbf{T1} — процессор выставляет адрес
\item \textbf{T2} — устройство готовится к обмену
\item \textbf{T3} — чтение или запись данных
\item \textbf{T4} — завершение, снятие сигналов
\item \textbf{Tw} — такты ожидания для медленных устройств
\end{itemize}

\subsubsection*{Вопрос 11. Прерывание — это...}

\textbf{Прерывание} — механизм, позволяющий приостановить выполнение текущей программы для обработки некоторого события (внешнего или внутреннего) с последующим возвратом к прерванной программе. Обеспечивает реакцию системы на асинхронные события.

\subsubsection*{Вопрос 12. Стек — это...}

\textbf{Стек} — область памяти, организованная по принципу LIFO (Last In — First Out): последний записанный элемент извлекается первым. Используется для хранения адресов возврата, параметров функций, локальных переменных.

\subsubsection*{Вопрос 13. Принцип работы стека.}

В архитектуре x86 стек растёт в сторону \textbf{младших адресов}:
\begin{itemize}
\item При записи (PUSH): сначала SP уменьшается, затем данные записываются по адресу [SP]
\item При чтении (POP): данные читаются из [SP], затем SP увеличивается
\end{itemize}
Регистр SP (Stack Pointer) всегда указывает на последний записанный элемент.

\subsubsection*{Вопрос 14. Пример записи и чтения из стека.}

\begin{verbatim}
    MOV AX, 1234h      ; AX = 1234h
    MOV BX, 5678h      ; BX = 5678h
    
    PUSH AX            ; SP = SP - 2, [SP] = 1234h
    PUSH BX            ; SP = SP - 2, [SP] = 5678h
    
    POP CX             ; CX = [SP] = 5678h, SP = SP + 2
    POP DX             ; DX = [SP] = 1234h, SP = SP + 2
    
    ; Результат: CX = 5678h, DX = 1234h (обратный порядок!)
\end{verbatim}

\subsubsection*{Вопрос 15. Команды, используемые при обращении к стеку.}

\begin{center}
\begin{tabular}{|l|p{9cm}|}
\hline
\texttt{PUSH src} & Запись в стек: SP = SP - 2 (или 4), [SP] = src \\
\hline
\texttt{POP dst} & Чтение из стека: dst = [SP], SP = SP + 2 (или 4) \\
\hline
\texttt{PUSHA/PUSHAD} & Сохранить все регистры общего назначения \\
\hline
\texttt{POPA/POPAD} & Восстановить все регистры общего назначения \\
\hline
\texttt{PUSHF/PUSHFD} & Сохранить регистр флагов \\
\hline
\texttt{POPF/POPFD} & Восстановить регистр флагов \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 16. Команды, используемые при вызове и возврате из подпрограммы.}

\begin{center}
\begin{tabular}{|l|p{9cm}|}
\hline
\texttt{CALL addr} & Вызов подпрограммы: сохраняет адрес следующей команды в стек (PUSH IP), затем переходит по адресу addr \\
\hline
\texttt{RET} & Возврат: извлекает адрес из стека (POP IP) и передаёт управление \\
\hline
\texttt{RET n} & Возврат с очисткой стека: после возврата SP увеличивается на n байт \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 17. Типы прерываний (перечислите и опишите назначение).}

\begin{enumerate}
\item \textbf{Аппаратные (внешние)} — генерируются периферийными устройствами (клавиатура, таймер, диск). Асинхронны по отношению к программе. Сигнализируют о событиях, требующих внимания.

\item \textbf{Программные} — вызываются командой \texttt{INT n}. Синхронны. Используются для системных вызовов ОС и сервисов BIOS.

\item \textbf{Исключения (exceptions)} — возникают при ошибках выполнения команд: деление на ноль, обращение к несуществующей странице (page fault), нарушение защиты.
\end{enumerate}

\subsubsection*{Вопрос 18. Какие прерывания могут быть маскируемыми, а какие нет.}

\textbf{Маскируемые:}
\begin{itemize}
\item Аппаратные прерывания, приходящие по линии INTR
\item Можно запретить сбросом флага IF
\end{itemize}

\textbf{Немаскируемые (NMI):}
\begin{itemize}
\item Приходят по отдельной линии NMI
\item Критические события: ошибка памяти, сбой питания
\item Исключения процессора
\item Программные прерывания INT n
\end{itemize}

\subsubsection*{Вопрос 19. Как происходит маскирование прерываний.}

Два способа:
\begin{enumerate}
\item \textbf{Глобальное} — через флаг IF в регистре флагов:
\begin{itemize}
\item \texttt{CLI} — сброс IF (IF=0), запрет всех маскируемых прерываний
\item \texttt{STI} — установка IF (IF=1), разрешение прерываний
\end{itemize}

\item \textbf{Индивидуальное} — через контроллер прерываний:
\begin{itemize}
\item Запись маски в регистр IMR контроллера 8259A или APIC
\item Позволяет запретить отдельные линии IRQ
\end{itemize}
\end{enumerate}

\subsubsection*{Вопрос 20. По каким ситуациям происходит вызов программных прерываний.}

\begin{itemize}
\item \textbf{Системные вызовы ОС} — INT 21h (DOS), INT 80h (Linux)
\item \textbf{Сервисы BIOS} — INT 10h (видео), INT 13h (диск), INT 16h (клавиатура)
\item \textbf{Отладка} — INT 3 (точка останова), INT 1 (пошаговый режим)
\item \textbf{Обработка ошибок} — INT 0 (деление на ноль)
\end{itemize}

\subsubsection*{Вопрос 21. Перечислите последовательность событий при входе процессора в прерывание.}

\begin{enumerate}
\item Завершение выполнения текущей команды
\item Сохранение регистра флагов в стек (PUSH FLAGS)
\item Сброс флагов IF и TF (запрет прерываний и трассировки)
\item Сохранение CS в стек (PUSH CS)
\item Сохранение IP в стек (PUSH IP)
\item Чтение адреса обработчика из таблицы векторов
\item Загрузка нового CS:IP и передача управления обработчику
\end{enumerate}

\subsubsection*{Вопрос 22. Обработчик прерывания — это...}

\textbf{Обработчик прерывания (ISR — Interrupt Service Routine)} — подпрограмма, выполняющая действия по обслуживанию прерывания. Должен сохранить используемые регистры, выполнить обработку события, послать подтверждение контроллеру (EOI) и завершиться командой IRET.

\subsubsection*{Вопрос 23. Где располагается обработчик прерывания.}

Обработчик располагается в \textbf{оперативной памяти}. Его адрес хранится в таблице векторов прерываний. Обработчики могут быть частью BIOS, операционной системы или пользовательской программы.

\subsubsection*{Вопрос 24. Вектор прерывания — это...}

\textbf{Вектор прерывания} — адрес обработчика прерывания. В реальном режиме x86 это 4 байта: 2 байта смещения (offset) + 2 байта сегмента (segment). Номер прерывания (0-255) служит индексом в таблице векторов.

\subsubsection*{Вопрос 25. Таблица векторов прерываний — это...}

\textbf{Таблица векторов прерываний (IVT)} — массив адресов обработчиков для всех 256 возможных прерываний. Размер: 256 × 4 = 1024 байта. По номеру прерывания n адрес обработчика находится по смещению n × 4.

\subsubsection*{Вопрос 26. Таблица векторов прерываний находится...}

\begin{itemize}
\item \textbf{Реальный режим x86:} по адресу \texttt{0000:0000} (первый килобайт памяти)
\item \textbf{Защищённый режим:} расположение определяется регистром IDTR (Interrupt Descriptor Table Register), таблица называется IDT
\end{itemize}

\subsubsection*{Вопрос 27. Обслуживание прерываний бывает (перечислите, поясните).}

\begin{enumerate}
\item \textbf{Последовательное (невложенное):}
\begin{itemize}
\item Во время обработки прерывания другие прерывания запрещены (IF=0)
\item Новые запросы ждут завершения текущего обработчика
\item Простота, но возможны задержки для критичных событий
\end{itemize}

\item \textbf{Вложенное (nested):}
\begin{itemize}
\item Более приоритетное прерывание может прервать обработчик
\item Обработчик должен разрешить прерывания (STI) и сохранить контекст
\item Быстрая реакция на критические события
\end{itemize}
\end{enumerate}

\subsubsection*{Вопрос 28. Какой бывает приоритизация прерываний (перечислите, поясните).}

\begin{enumerate}
\item \textbf{Фиксированная:} приоритеты жёстко заданы (чем меньше номер IRQ, тем выше приоритет). Просто, но негибко.

\item \textbf{Циклическая (ротируемая):} после обслуживания устройства его приоритет становится наименьшим. Равномерное распределение времени.

\item \textbf{Программируемая:} приоритеты задаются программно через регистры контроллера. Максимальная гибкость.
\end{enumerate}

\subsubsection*{Вопрос 29. Контроллер прерываний. Сколько линий в многопроцессорных системах?}

\textbf{8259A PIC:} 8 линий на контроллер, каскад из двух = 15 линий (одна для каскадирования).

\textbf{APIC (Advanced PIC):} I/O APIC имеет \textbf{24 линии прерываний}. Каждый процессор имеет Local APIC. Поддерживает межпроцессорные прерывания (IPI) и MSI.

\subsubsection*{Вопрос 30. Как центральный процессор узнаёт об аппаратном прерывании?}

Контроллер прерываний выставляет сигнал на линии \textbf{INTR} (для маскируемых) или \textbf{NMI} (для немаскируемых). Процессор проверяет эти линии между выполнением команд. Если IF=1 и есть сигнал на INTR, процессор начинает цикл подтверждения.

\subsubsection*{Вопрос 31. Как устройства ввода-вывода узнают о подтверждении запроса на прерывание.}

Процессор генерирует два импульса сигнала \textbf{INTA (Interrupt Acknowledge)}:
\begin{enumerate}
\item Первый импульс — уведомляет контроллер о начале обработки
\item Второй импульс — запрашивает номер вектора прерывания
\end{enumerate}
Контроллер выставляет номер вектора на шину данных.

\subsubsection*{Вопрос 32. Системные ресурсы — это...}

Аппаратные ресурсы, выделяемые устройствам для взаимодействия с системой:
\begin{itemize}
\item \textbf{Адреса портов ввода-вывода} (I/O ports)
\item \textbf{Номера прерываний} (IRQ)
\item \textbf{Каналы DMA} (прямой доступ к памяти)
\item \textbf{Области памяти} (memory ranges)
\end{itemize}

\subsubsection*{Вопрос 33. Адреса портов ввода-вывода делятся на 2 группы. По какому принципу?}

\begin{enumerate}
\item \textbf{Фиксированные} — для стандартных устройств, адреса определены стандартом:
\begin{itemize}
\item Клавиатура — 60h
\item Таймер — 40h-43h
\item COM1 — 3F8h
\end{itemize}

\item \textbf{Назначаемые (конфигурируемые)} — для устройств PCI, USB, PnP. Адреса назначаются BIOS или ОС при инициализации.
\end{enumerate}

\subsubsection*{Вопрос 34. Plug and Play — это... (в чём его необходимость)?}

\textbf{Plug and Play (PnP)} — технология автоматического обнаружения и конфигурирования устройств без ручного задания ресурсов.

Необходимость:
\begin{itemize}
\item Устранение конфликтов ресурсов (два устройства с одним IRQ)
\item Упрощение установки оборудования для пользователя
\item Автоматическое определение оптимальных настроек
\item Динамическое перераспределение ресурсов
\end{itemize}

\subsubsection*{Вопрос 35. Мезонинная архитектура — это... (приведите пример, рисунок)}

Архитектура с использованием \textbf{дочерних плат (мезонинов)}, устанавливаемых на базовую (несущую) плату:
\begin{verbatim}
+--------------------------------------------------+
|              Базовая (несущая) плата             |
|  +----------+   +----------+   +----------+      |
|  | Мезонин  |   | Мезонин  |   | Мезонин  |      |
|  |    1     |   |    2     |   |    3     |      |
|  +----------+   +----------+   +----------+      |
+--------------------------------------------------+
\end{verbatim}
Примеры стандартов: PMC, XMC, FMC, AMC.

\subsubsection*{Вопрос 36. Шина PCI и аппаратные прерывания. Какие линии используются?}

PCI использует \textbf{4 линии прерываний}: INTA\#, INTB\#, INTC\#, INTD\#.

Особенности:
\begin{itemize}
\item Линии разделяемые (shared) — несколько устройств на одной линии
\item Уровневая сигнализация (level-triggered)
\item Маршрутизируются через чипсет на IRQ
\item Современные системы используют MSI (Message Signaled Interrupts)
\end{itemize}

\subsubsection*{Вопрос 37. Приведите пример структурной схемы ЭВМ с магистральным принципом построения.}

\begin{verbatim}
+================================================================+
|                     Системная магистраль                        |
+================================================================+
     |          |          |          |          |
+--------+ +--------+ +--------+ +--------+ +--------+
|  CPU   | |  RAM   | |  ROM   | | Порт 1 | | Порт 2 |
+--------+ +--------+ +--------+ +--------+ +--------+
\end{verbatim}

Все устройства подключены к общей шине и обмениваются данными через неё. Арбитраж определяет, кто в данный момент использует шину.

\subsubsection*{Вопрос 38. При помощи каких команд происходит обращение к подпрограмме и возврат из неё.}

\begin{itemize}
\item \texttt{CALL addr} — вызов: сохраняет IP (и CS для дальнего вызова) в стек, переходит к addr
\item \texttt{RET} — возврат: извлекает IP из стека, передаёт управление
\item \texttt{RET n} — возврат с очисткой n байт параметров из стека
\end{itemize}

\subsubsection*{Вопрос 39. В зависимости от источника возникновения сигнала прерывания делятся на...?}

\begin{enumerate}
\item \textbf{Внешние (аппаратные)} — от периферийных устройств через линии INTR/NMI
\item \textbf{Внутренние (исключения)} — генерируются самим процессором при ошибках
\item \textbf{Программные} — вызываются командой INT n
\end{enumerate}

\subsubsection*{Вопрос 40. Программируемый контроллер прерываний APIC. Чем отличается от каскада контроллеров прерываний?}

\begin{center}
\begin{tabular}{|p{5cm}|p{5cm}|}
\hline
\textbf{Каскад 8259A} & \textbf{APIC} \\
\hline
15 линий прерываний & 24 линии (I/O APIC) \\
\hline
Только однопроцессорные системы & Поддержка многопроцессорности (SMP) \\
\hline
Фиксированная маршрутизация & Гибкая маршрутизация на любой CPU \\
\hline
Нет межпроцессорных прерываний & Поддержка IPI \\
\hline
Edge/level triggered & + MSI (Message Signaled Interrupts) \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 41. Чем определяется (ограничивается) тактовая частота процессора?}

\begin{itemize}
\item \textbf{Задержки переключения транзисторов} — физический предел скорости
\item \textbf{Тепловыделение} — при высокой частоте выделяется больше тепла
\item \textbf{Паразитные ёмкости и индуктивности} — искажают сигналы
\item \textbf{Стабильность питания} — высокая частота требует качественного питания
\item \textbf{Распространение тактового сигнала} — сложность синхронизации
\end{itemize}

\subsubsection*{Вопрос 42. В чём причина зависимости между частотой и потребляемой мощностью?}

Динамическая мощность КМОП-схем:
\[ P = C \cdot V^2 \cdot f \]
где $C$ — паразитная ёмкость, $V$ — напряжение, $f$ — частота.

Причины пропорциональности:
\begin{itemize}
\item Мощность линейно зависит от частоты переключений
\item При повышении частоты часто требуется повышение напряжения
\item Токи утечки растут с уменьшением размеров транзисторов
\end{itemize}

\subsubsection*{Вопрос 43. Какие существуют способы оценки производительности цифрового компьютера?}

\begin{itemize}
\item \textbf{Тактовая частота} — простой, но неточный показатель
\item \textbf{MIPS} — миллионы команд в секунду
\item \textbf{FLOPS} — операции с плавающей точкой в секунду (для научных вычислений)
\item \textbf{Бенчмарки} — SPEC CPU, Geekbench, Cinebench
\item \textbf{Время выполнения реальных задач} — наиболее объективный метод
\item \textbf{CPI} — среднее число тактов на команду
\end{itemize}

\subsubsection*{Вопрос 44. Назовите три основных класса цифровых компьютеров и их особенности.}

\begin{enumerate}
\item \textbf{Персональные компьютеры:}
\begin{itemize}
\item Универсальные, для индивидуального использования
\item Баланс цены и производительности
\item Интерактивная работа пользователя
\end{itemize}

\item \textbf{Серверы:}
\begin{itemize}
\item Высокая производительность и надёжность
\item Обслуживание множества клиентов
\item Отказоустойчивость, работа 24/7
\end{itemize}

\item \textbf{Встраиваемые системы:}
\begin{itemize}
\item Специализированные под конкретную задачу
\item Ограниченные ресурсы, низкое энергопотребление
\item Работа в реальном времени
\end{itemize}
\end{enumerate}

\subsubsection*{Вопрос 45. Назовите и охарактеризуйте основные части структуры простейшего цифрового компьютера.}

\begin{enumerate}
\item \textbf{Процессор (CPU)} — выполняет команды, арифметические и логические операции, управляет работой системы

\item \textbf{Память} — хранит программы и данные (ОЗУ — оперативная, ПЗУ — постоянная)

\item \textbf{Устройства ввода-вывода} — обеспечивают взаимодействие с внешним миром (клавиатура, дисплей, диски)

\item \textbf{Системная шина} — обеспечивает связь между компонентами
\end{enumerate}

\subsubsection*{Вопрос 46. В чём смысл понятия машинное слово?}

\textbf{Машинное слово} — единица данных, которую процессор обрабатывает за одну операцию. Размер определяется архитектурой:
\begin{itemize}
\item 8-битные процессоры: слово = 8 бит
\item 16-битные (8086): слово = 16 бит
\item 32-битные (i386): слово = 32 бита
\item 64-битные (x86-64): слово = 64 бита
\end{itemize}

\subsubsection*{Вопрос 47. В чём смысл понятия минимальная адресуемая единица (МАЕ)?}

\textbf{МАЕ} — наименьший объём памяти, имеющий собственный уникальный адрес.

Возможные размеры:
\begin{itemize}
\item \textbf{1 байт (8 бит)} — наиболее распространённый (x86, ARM)
\item \textbf{1 слово} — в некоторых DSP-процессорах
\item \textbf{1 бит} — в специализированных системах
\end{itemize}

\subsubsection*{Вопрос 48. Что называют физическим адресом?}

\textbf{Физический адрес} — реальный адрес ячейки в физической памяти, который выставляется на адресную шину. В системах с виртуальной памятью получается преобразованием виртуального адреса блоком MMU (Memory Management Unit).

\subsubsection*{Вопрос 49. Какие группы регистров выделяют в модели программиста?}

\begin{enumerate}
\item \textbf{Регистры общего назначения (РОН)} — хранение данных и адресов\\
x86: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP

\item \textbf{Сегментные регистры} — адресация сегментов памяти\\
x86: CS, DS, SS, ES, FS, GS

\item \textbf{Регистр состояния (флагов)} — результаты операций, управление\\
x86: FLAGS/EFLAGS/RFLAGS

\item \textbf{Указатель команд} — адрес следующей команды\\
x86: IP/EIP/RIP
\end{enumerate}

\subsubsection*{Вопрос 50. В чём состоит назначение регистра состояния в цифровом процессоре.}

\textbf{Регистр состояния (FLAGS)} хранит:
\begin{itemize}
\item \textbf{Флаги результата:} CF (перенос), ZF (ноль), SF (знак), OF (переполнение), PF (чётность)
\item \textbf{Управляющие флаги:} IF (разрешение прерываний), DF (направление), TF (трассировка)
\end{itemize}
Используется для условных переходов и управления режимами процессора.

\subsubsection*{Вопрос 51. Назначение и функция регистра счётчика команд (указателя команд).}

\textbf{Указатель команд (IP/EIP/RIP)} содержит адрес следующей команды.

Функции:
\begin{itemize}
\item Автоматически увеличивается после выборки каждой команды
\item Изменяется командами переходов (JMP, CALL, RET)
\item Изменяется при входе в прерывание и возврате (IRET)
\end{itemize}

\subsubsection*{Вопрос 52. Какие регистры x86 могут использоваться в качестве операндов?}

\begin{itemize}
\item \textbf{32-битные РОН:} EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP
\item \textbf{16-битные части:} AX, BX, CX, DX, SI, DI, BP, SP
\item \textbf{8-битные части:} AH, AL, BH, BL, CH, CL, DH, DL
\item \textbf{Сегментные:} CS, DS, ES, SS, FS, GS (с ограничениями)
\end{itemize}

\subsubsection*{Вопрос 53. Является ли счётчик команд в x86 программно доступным?}

\textbf{Нет}, счётчик команд (IP/EIP/RIP) \textbf{программно недоступен} — его нельзя использовать как операнд-источник или операнд-приёмник в командах. Изменяется только косвенно: командами переходов, вызовов, возвратов и прерываний.

\subsubsection*{Вопрос 54. В чём состоит функция АЛУ?}

\textbf{АЛУ (Арифметико-Логическое Устройство)} выполняет:
\begin{itemize}
\item Арифметические операции: сложение, вычитание, умножение, деление
\item Логические операции: AND, OR, XOR, NOT
\item Сдвиги и вращения битов
\item Сравнение операндов
\item Формирование флагов результата
\end{itemize}

\subsubsection*{Вопрос 55. Структурные части типовой процессорной команды и их назначение.}

\begin{enumerate}
\item \textbf{Код операции (opcode)} — определяет, какое действие выполнить
\item \textbf{Операнд-приёмник (destination)} — куда записать результат
\item \textbf{Операнд-источник (source)} — откуда взять данные
\item \textbf{Модификаторы адресации (ModR/M, SIB)} — как найти операнды
\item \textbf{Непосредственное значение} — константа в команде
\item \textbf{Смещение} — для адресации памяти
\end{enumerate}

\subsubsection*{Вопрос 56. Объясните, каким может быть поведение флагов при выполнении команд.}

\begin{enumerate}
\item \textbf{Устанавливаются} — флаг становится 1 по условию
\item \textbf{Сбрасываются} — флаг становится 0 по условию
\item \textbf{Модифицируются} — изменяются в соответствии с результатом
\item \textbf{Не изменяются} — команда не влияет на флаг
\item \textbf{Не определены} — значение непредсказуемо после команды
\end{enumerate}

Пример: ADD модифицирует CF, ZF, SF, OF; MOV не изменяет флаги; MUL оставляет ZF, SF неопределёнными.

\subsubsection*{Вопрос 57. Изменяются ли значения флагов при выполнении команд пересылки данных?}

\textbf{Нет}, команды пересылки данных (MOV, XCHG, PUSH, POP, LEA) \textbf{не изменяют флаги}. Это важное свойство, позволяющее сохранять результат предыдущей операции для последующего условного перехода.

\subsubsection*{Вопрос 58. Приведите разновидности команд с условным исполнением в x86.}

\begin{enumerate}
\item \textbf{Условные переходы (Jcc):} JZ, JNZ, JC, JNC, JG, JL, JA, JB, JO, JS и др.

\item \textbf{Условная пересылка (CMOVcc):} CMOVZ, CMOVNZ, CMOVG, CMOVL — пересылка выполняется только при выполнении условия

\item \textbf{Условная установка байта (SETcc):} SETZ, SETNZ — устанавливает байт в 1 или 0 в зависимости от условия

\item \textbf{Условные циклы:} LOOPE, LOOPNE — цикл с дополнительным условием
\end{enumerate}

\subsubsection*{Вопрос 59. Какие команды помогают в организации вычислений с повышенной разрядностью?}

\begin{center}
\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{ADC dst, src} & Сложение с переносом: dst = dst + src + CF \\
\hline
\texttt{SBB dst, src} & Вычитание с заёмом: dst = dst - src - CF \\
\hline
\texttt{MUL src} & Умножение с двойным результатом: EDX:EAX = EAX × src \\
\hline
\texttt{IMUL src} & Знаковое умножение с двойным результатом \\
\hline
\texttt{DIV src} & Деление двойного делимого: EAX = EDX:EAX / src \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 60. Что происходит с операндом-источником при выполнении команд пересылки?}

Операнд-источник \textbf{остаётся неизменным}. Данные \textbf{копируются}, а не перемещаются. После команды MOV EAX, EBX значение в EBX сохраняется, в EAX записывается копия.

\subsubsection*{Вопрос 61. Почему для машинного представления чисел используется двоичная система?}

\begin{itemize}
\item \textbf{Простота реализации} — два устойчивых состояния (ток есть/нет, напряжение высокое/низкое)
\item \textbf{Помехоустойчивость} — большой запас между уровнями 0 и 1
\item \textbf{Надёжность} — меньше вероятность ошибки распознавания
\item \textbf{Математическая основа} — булева алгебра для логических операций
\end{itemize}

\subsubsection*{Вопрос 62. Всегда ли используется двоичная система кодирования?}

\textbf{Нет}, существуют альтернативные системы:
\begin{itemize}
\item \textbf{BCD} — двоично-десятичный код (4 бита на цифру)
\item \textbf{Код Грея} — соседние значения отличаются одним битом
\item \textbf{ASCII, Unicode} — кодирование символов
\item \textbf{Коды с исправлением ошибок} — код Хэмминга, ECC
\end{itemize}

\subsubsection*{Вопрос 63. Для чего используются восьмеричная и шестнадцатеричная системы?}

Для \textbf{компактной записи двоичных чисел}:
\begin{itemize}
\item 1 восьмеричная цифра = 3 бита
\item 1 шестнадцатеричная цифра = 4 бита (полубайт)
\end{itemize}
Пример: $11010110_2 = D6_{16} = 326_8$

\subsubsection*{Вопрос 64. Как перевести число из одной позиционной системы счисления в другую?}

\textbf{В десятичную:}
\[ N_{10} = \sum_{i} a_i \cdot p^i \]
где $a_i$ — цифры, $p$ — основание исходной системы.

\textbf{Из десятичной:}
\begin{itemize}
\item Целая часть: последовательное деление на основание, остатки — цифры (снизу вверх)
\item Дробная часть: последовательное умножение на основание, целые части — цифры
\end{itemize}

\subsubsection*{Вопрос 65. Каков диапазон представимых значений в n-битовой сетке для беззнаковых чисел?}

\[ 0 \leq x \leq 2^n - 1 \]

Примеры:
\begin{itemize}
\item 8 бит: 0 ... 255
\item 16 бит: 0 ... 65535
\item 32 бита: 0 ... 4 294 967 295
\end{itemize}

\subsubsection*{Вопрос 66. Каков диапазон представимых значений в n-битовой сетке для знаковых чисел (дополнительный код)?}

\[ -2^{n-1} \leq x \leq 2^{n-1} - 1 \]

Примеры:
\begin{itemize}
\item 8 бит: -128 ... +127
\item 16 бит: -32768 ... +32767
\item 32 бита: -2 147 483 648 ... +2 147 483 647
\end{itemize}

\subsubsection*{Вопрос 67. Как обнаруживается переполнение разрядной сетки при сложении/вычитании?}

\begin{itemize}
\item \textbf{Для беззнаковых:} флаг \textbf{CF (Carry Flag)} — перенос из старшего бита
\item \textbf{Для знаковых:} флаг \textbf{OF (Overflow Flag)} — устанавливается, когда знак результата некорректен (оба операнда одного знака, результат — противоположного)
\end{itemize}

\subsubsection*{Вопрос 68. Что делать, если диапазон целочисленных операндов слишком мал?}

\begin{itemize}
\item Использовать типы \textbf{большей разрядности} (16 → 32 → 64 бита)
\item Использовать \textbf{библиотеки длинной арифметики}
\item Применять \textbf{команды ADC/SBB} для вычислений с повышенной разрядностью
\item Использовать \textbf{числа с плавающей точкой} (с потерей точности)
\end{itemize}

\subsubsection*{Вопрос 69. Как поменять знак двоичного числа в дополнительном коде?}

\textbf{Алгоритм:} инвертировать все биты и прибавить 1.

\textbf{Команда x86:} \texttt{NEG dst} — выполняет dst = 0 - dst

Пример:
\begin{verbatim}
+5  = 00000101
инв = 11111010
+1  = 11111011 = -5
\end{verbatim}

\subsubsection*{Вопрос 70. Для чего используется команда AND?}

\texttt{AND dst, src} — побитовое логическое И.

Применения:
\begin{itemize}
\item \textbf{Маскирование (обнуление) битов:} \texttt{AND AL, 0Fh} — обнуляет старшие 4 бита
\item \textbf{Проверка битов:} \texttt{AND AL, 01h} — ZF=1 если младший бит = 0
\item \textbf{Выделение битового поля}
\end{itemize}

\subsubsection*{Вопрос 71. Для чего используется команда OR?}

\texttt{OR dst, src} — побитовое логическое ИЛИ.

Применения:
\begin{itemize}
\item \textbf{Установка битов в 1:} \texttt{OR AL, 80h} — устанавливает старший бит
\item \textbf{Объединение битовых полей}
\item \textbf{Проверка на ноль:} \texttt{OR EAX, EAX} — ZF=1 если EAX=0
\end{itemize}

\subsubsection*{Вопрос 72. Для чего используется команда XOR?}

\texttt{XOR dst, src} — побитовое исключающее ИЛИ.

Применения:
\begin{itemize}
\item \textbf{Обнуление регистра:} \texttt{XOR EAX, EAX} — самый быстрый способ
\item \textbf{Инверсия битов:} \texttt{XOR AL, 0FFh}
\item \textbf{Переключение бита:} \texttt{XOR AL, 01h}
\item \textbf{Простое шифрование} — XOR с ключом
\end{itemize}

\subsubsection*{Вопрос 73. Чем определяются точность и диапазон чисел с плавающей точкой?}

Формат числа: $(-1)^S \times M \times 2^E$

\begin{itemize}
\item \textbf{Точность} определяется количеством бит \textbf{мантиссы} (M)
\item \textbf{Диапазон} определяется количеством бит \textbf{порядка} (экспоненты E)
\end{itemize}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
Формат & Порядок & Мантисса & Всего \\
\hline
float & 8 бит & 23 бита & 32 бита \\
double & 11 бит & 52 бита & 64 бита \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 74. Как преодолевают неоднозначность представления числа в формате ПТ?}

Одно число можно представить по-разному: $1.5 \times 2^3 = 3.0 \times 2^2 = 0.75 \times 2^4$

Решение — \textbf{нормализация}: приведение к единственной стандартной форме.

\subsubsection*{Вопрос 75. Что такое нормализация числа ПТ?}

\textbf{Нормализация} — приведение мантиссы к виду $1.xxx..._2$, где старший бит всегда равен 1. Это обеспечивает единственность представления и максимальную точность.

\subsubsection*{Вопрос 76. Какое преимущество имеет нормализованное представление?}

\begin{itemize}
\item Единственное представление каждого числа
\item \textbf{Максимальная точность} — все биты мантиссы значащие
\item Возможность использования скрытого бита
\end{itemize}

\subsubsection*{Вопрос 77. За счёт чего можно не хранить старший бит мантиссы?}

В нормализованном представлении старший бит мантиссы \textbf{всегда равен 1}. Поэтому его можно не хранить (\textbf{скрытый бит}), получая дополнительный бит точности бесплатно.

\subsubsection*{Вопрос 78. Что такое <<псевдонуль>>?}

\textbf{Псевдонуль (денормализованное число)} — число с нулевым порядком и ненулевой мантиссой. Используется для представления очень малых чисел, близких к нулю, расширяя диапазон в сторону малых значений.

\subsubsection*{Вопрос 79. Сколько разновидностей сдвига реализовано в x86 и каковы их свойства?}

\begin{center}
\begin{tabular}{|l|l|p{5.5cm}|}
\hline
\textbf{Команда} & \textbf{Название} & \textbf{Свойства} \\
\hline
SHL/SAL & Сдвиг влево & Младшие биты заполняются 0. Умножение на $2^n$ \\
\hline
SHR & Логический сдвиг вправо & Старшие биты заполняются 0. Для беззнаковых — деление на $2^n$ \\
\hline
SAR & Арифметический сдвиг вправо & Знаковый бит сохраняется. Для знаковых — деление на $2^n$ \\
\hline
ROL & Циклический влево & Выдвигаемый бит возвращается справа \\
\hline
ROR & Циклический вправо & Выдвигаемый бит возвращается слева \\
\hline
RCL & Циклический влево через CF & В цикл включён флаг CF \\
\hline
RCR & Циклический вправо через CF & В цикл включён флаг CF \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 80. Какие команды позволяют проверить операнд на условия =0, >0 и т.п.?}

\begin{itemize}
\item \texttt{CMP dst, src} — сравнение: вычисляет dst - src, устанавливает флаги, результат не сохраняет
\item \texttt{TEST dst, src} — проверка: вычисляет dst AND src, устанавливает флаги, результат не сохраняет
\end{itemize}

После этих команд используются условные переходы (Jcc).

\subsubsection*{Вопрос 81. Условия команд ветвления разбиты на три подгруппы. Укажите их.}

\begin{enumerate}
\item \textbf{Для беззнаковых (Above/Below):}
\begin{itemize}
\item JA/JNBE — выше (CF=0 и ZF=0)
\item JAE/JNB — выше или равно (CF=0)
\item JB/JNAE — ниже (CF=1)
\item JBE/JNA — ниже или равно (CF=1 или ZF=1)
\end{itemize}

\item \textbf{Для знаковых (Greater/Less):}
\begin{itemize}
\item JG/JNLE — больше (ZF=0 и SF=OF)
\item JGE/JNL — больше или равно (SF=OF)
\item JL/JNGE — меньше (SF$\neq$OF)
\item JLE/JNG — меньше или равно (ZF=1 или SF$\neq$OF)
\end{itemize}

\item \textbf{По отдельным флагам:}
JZ/JE, JNZ/JNE, JC, JNC, JS, JNS, JO, JNO, JP, JNP
\end{enumerate}

\subsubsection*{Вопрос 82. Есть две команды <<переход, если больше нуля>>. Как выбрать?}

\begin{itemize}
\item \texttt{JA} (Jump if Above) — для \textbf{беззнаковых} чисел
\item \texttt{JG} (Jump if Greater) — для \textbf{знаковых} чисел
\end{itemize}

Пример: FFh как беззнаковое = 255 > 0 (JA сработает), как знаковое = -1 < 0 (JG не сработает).

\subsubsection*{Вопрос 83. Как организовать цикл, если специальная команда отсутствует?}

\begin{verbatim}
        MOV CX, count      ; Счётчик итераций
loop_start:
        ; ... тело цикла ...
        DEC CX             ; CX = CX - 1
        JNZ loop_start     ; Если CX != 0, повторить
\end{verbatim}

\subsubsection*{Вопрос 84. Есть ли специальная команда организации цикла в x86?}

\textbf{Да:}
\begin{itemize}
\item \texttt{LOOP label} — уменьшает CX/ECX на 1, переход если CX$\neq$0
\item \texttt{LOOPE/LOOPZ} — переход если CX$\neq$0 И ZF=1
\item \texttt{LOOPNE/LOOPNZ} — переход если CX$\neq$0 И ZF=0
\end{itemize}

Примечание: на современных процессорах DEC+JNZ часто быстрее, чем LOOP.

\subsubsection*{Вопрос 85. Какие регистры x86 можно использовать в косвенно-регистровой адресации?}

\begin{itemize}
\item \textbf{32-битный режим:} EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP
\item \textbf{16-битный режим:} только BX, BP, SI, DI
\end{itemize}

\subsubsection*{Вопрос 86. Чем отличается CALL от JMP?}

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
& \textbf{JMP} & \textbf{CALL} \\
\hline
Сохранение адреса возврата & Нет & Да (в стек) \\
\hline
Возможность возврата & Нет & Да (командой RET) \\
\hline
Назначение & Безусловный переход & Вызов подпрограммы \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 87. Каковы основные действия команды вызова подпрограммы?}

\begin{enumerate}
\item \texttt{ESP = ESP - 4} (в 32-битном режиме)
\item \texttt{[ESP] = EIP} (сохранение адреса следующей команды)
\item \texttt{EIP = адрес\_подпрограммы} (переход)
\end{enumerate}

\subsubsection*{Вопрос 88. Где может сохраняться адрес возврата?}

\begin{itemize}
\item \textbf{В стеке} — x86, ARM (при вызовах с сохранением LR)
\item \textbf{В регистре связи (Link Register)} — многие RISC-процессоры (ARM, PowerPC)
\item \textbf{В первой ячейке подпрограммы} — старые архитектуры
\end{itemize}

\subsubsection*{Вопрос 89. Что такое <<контекст программы>>?}

\textbf{Контекст программы} — полное состояние процессора, необходимое для продолжения выполнения:
\begin{itemize}
\item Регистры общего назначения
\item Регистр флагов
\item Указатель команд (IP)
\item Указатель стека (SP)
\item Сегментные регистры
\end{itemize}

\subsubsection*{Вопрос 90. Зачем требуется сохранение или восстановление контекста?}

\begin{itemize}
\item При \textbf{вызове подпрограмм} — чтобы не испортить данные вызывающей функции
\item При \textbf{обработке прерываний} — чтобы вернуться к прерванной программе
\item При \textbf{переключении задач} — для многозадачности в ОС
\item При \textbf{обработке исключений}
\end{itemize}

\subsubsection*{Вопрос 91. Какие команды помогают сохранять-восстанавливать контекст в x86?}

\begin{center}
\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{PUSH reg / POP reg} & Сохранение/восстановление одного регистра \\
\hline
\texttt{PUSHA / POPA} & Все 16-битные РОН (AX,CX,DX,BX,SP,BP,SI,DI) \\
\hline
\texttt{PUSHAD / POPAD} & Все 32-битные РОН \\
\hline
\texttt{PUSHF / POPF} & Регистр флагов (16 бит) \\
\hline
\texttt{PUSHFD / POPFD} & Регистр флагов (32 бита) \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 92. Что такое <<стековый кадр>>?}

\textbf{Стековый кадр (stack frame)} — область стека, выделяемая для одного вызова функции:
\begin{verbatim}
[EBP+12]  Параметр 2
[EBP+8]   Параметр 1
[EBP+4]   Адрес возврата
[EBP]     Сохранённый EBP  <-- EBP указывает сюда
[EBP-4]   Локальная 1
[EBP-8]   Локальная 2      <-- ESP указывает сюда
\end{verbatim}

\subsubsection*{Вопрос 93. Как организуется доступ к элементам стекового кадра?}

Используется \textbf{базовая адресация} через регистр EBP:
\begin{itemize}
\item \texttt{[EBP+8]}, \texttt{[EBP+12]}, ... — параметры функции
\item \texttt{[EBP-4]}, \texttt{[EBP-8]}, ... — локальные переменные
\item \texttt{[EBP]} — сохранённый EBP вызывающей функции
\item \texttt{[EBP+4]} — адрес возврата
\end{itemize}

\subsubsection*{Вопрос 94. Что такое <<ввод-вывод, отображённый на память>> (MMIO)?}

\textbf{Memory-Mapped I/O} — способ организации, при котором регистры устройств располагаются в адресном пространстве памяти. Доступ через обычные команды MOV. Можно использовать все режимы адресации.

\subsubsection*{Вопрос 95. Что такое <<изолированный ввод-вывод>>?}

\textbf{Isolated I/O (Port-Mapped I/O)} — отдельное адресное пространство для портов ввода-вывода. Доступ через специальные команды IN и OUT. В x86: 64K портов (0000h-FFFFh).

\subsubsection*{Вопрос 96. Преимущества и недостатки изолированного ввода-вывода.}

\begin{center}
\begin{tabular}{|p{5.5cm}|p{5.5cm}|}
\hline
\textbf{Преимущества} & \textbf{Недостатки} \\
\hline
Не занимает адресное пространство памяти & Требуются специальные команды (IN/OUT) \\
\hline
Явное разделение памяти и устройств & Ограниченные возможности адресации \\
\hline
Легче контролировать доступ к портам & Меньше гибкости \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 97. Как организован ввод-вывод в архитектуре x86?}

Используется \textbf{изолированный ввод-вывод}:
\begin{itemize}
\item \texttt{IN AL, port} — ввод байта из порта
\item \texttt{IN AL, DX} — ввод, номер порта в DX
\item \texttt{OUT port, AL} — вывод байта в порт
\item \texttt{OUT DX, AL} — вывод, номер порта в DX
\end{itemize}
Также поддерживается MMIO для современных устройств (видеопамять, PCI).

\subsubsection*{Вопрос 98. Каковы недостатки синхронизации с использованием поллинга?}

\textbf{Поллинг} — циклическая проверка флага готовности устройства.

Недостатки:
\begin{itemize}
\item Непроизводительная трата процессорного времени
\item Задержка реакции (зависит от частоты опроса)
\item Невозможность эффективной работы с несколькими устройствами
\item Повышенное энергопотребление
\end{itemize}

\subsubsection*{Вопрос 99. Преимущества использования механизма прерывания.}

\begin{itemize}
\item Процессор свободен до наступления события
\item Быстрая реакция на события
\item Возможность приоритизации событий
\item Эффективная работа с множеством устройств
\item Экономия энергии (процессор может <<спать>>)
\end{itemize}

\subsubsection*{Вопрос 100. Различия между входом в подпрограмму и входом в обработчик прерывания.}

\begin{center}
\begin{tabular}{|p{5.5cm}|p{5.5cm}|}
\hline
\textbf{CALL (подпрограмма)} & \textbf{Прерывание} \\
\hline
Сохраняется только IP (и CS) & Сохраняются FLAGS, CS, IP \\
\hline
IF не изменяется & IF сбрасывается (прерывания запрещаются) \\
\hline
TF не изменяется & TF сбрасывается \\
\hline
Вызов синхронный & Вызов асинхронный \\
\hline
Возврат: RET & Возврат: IRET \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 101. Когда может начаться вход в прерывание по отношению к текущей команде?}

Вход в прерывание начинается \textbf{после завершения текущей команды}. Процессор не прерывает команду посередине. Исключение: некоторые длинные строковые команды (REP MOVS) могут быть прерваны.

\subsubsection*{Вопрос 102. Какова судьба запроса, пришедшего при запрещённых прерываниях?}

Запрос \textbf{остаётся активным} (удерживается контроллером прерываний) и будет обработан сразу после разрешения прерываний (STI), если к тому моменту не будет снят устройством.

\subsubsection*{Вопрос 103. Прервётся ли обработчик при запросе от более приоритетного источника?}

Зависит от режима:
\begin{itemize}
\item \textbf{При запрещённых прерываниях (IF=0):} нет, запрос будет ждать
\item \textbf{При разрешённых вложенных прерываниях:} да, если новый запрос более приоритетный
\end{itemize}

\subsubsection*{Вопрос 104. Как процессор узнаёт, где находится обработчик?}

По номеру прерывания процессор обращается к \textbf{таблице векторов прерываний}:
\begin{itemize}
\item Реальный режим: адрес = номер × 4, читает 4 байта (segment:offset) из IVT
\item Защищённый режим: читает дескриптор из IDT по регистру IDTR
\end{itemize}

\subsubsection*{Вопрос 105. При каких условиях допустимы вложенные прерывания?}

\begin{itemize}
\item Флаг IF установлен (командой STI) внутри обработчика
\item Новое прерывание имеет более высокий приоритет
\item Обработчик корректно сохраняет весь используемый контекст
\item Достаточно места в стеке
\end{itemize}

\subsubsection*{Вопрос 106. К каким последствиям может привести необдуманное разрешение вложенных прерываний?}

\begin{itemize}
\item \textbf{Переполнение стека} — каждое прерывание занимает место
\item \textbf{Взаимные блокировки (deadlock)} — при неправильной синхронизации
\item \textbf{Гонки данных} — при работе с разделяемыми ресурсами
\item \textbf{Инверсия приоритетов}
\item \textbf{Непредсказуемые задержки}
\end{itemize}

\subsubsection*{Вопрос 107. Что такое программные прерывания?}

\textbf{Программные прерывания} — прерывания, вызываемые командой \texttt{INT n}. Синхронны (выполняются в определённой точке программы). Используются для:
\begin{itemize}
\item Системных вызовов ОС
\item Вызова сервисов BIOS
\item Отладки (INT 3)
\end{itemize}

\subsubsection*{Вопрос 108. Какую функцию выполняет бит IF регистра состояния?}

\textbf{IF (Interrupt Flag)} — флаг разрешения прерываний:
\begin{itemize}
\item IF = 1 — маскируемые прерывания разрешены
\item IF = 0 — маскируемые прерывания запрещены
\end{itemize}
Управляется: CLI (сброс), STI (установка), автоматически при входе в прерывание (сброс).

\subsubsection*{Вопрос 109. Какую функцию выполняет бит TF регистра состояния?}

\textbf{TF (Trap Flag)} — флаг трассировки:
\begin{itemize}
\item TF = 1 — после каждой команды генерируется прерывание INT 1
\item TF = 0 — нормальное выполнение
\end{itemize}
Используется отладчиками для пошагового выполнения программы.

\subsubsection*{Вопрос 110. Требование к команде для организации точки останова.}

Команда точки останова должна:
\begin{enumerate}
\item Занимать \textbf{1 байт} — чтобы можно было заменить любую команду
\item Вызывать прерывание — для передачи управления отладчику
\end{enumerate}
В x86: \texttt{INT 3} имеет однобайтовый код \texttt{0xCC}.

\subsubsection*{Вопрос 111. Сколько векторов прерываний имеется в x86?}

\textbf{256 векторов} (номера 0-255):
\begin{itemize}
\item 0-31 — зарезервированы для исключений процессора
\item 32-255 — доступны для аппаратных и программных прерываний
\end{itemize}

\subsubsection*{Вопрос 112. Как разрешить/запретить аппаратные прерывания в x86?}

\begin{itemize}
\item \texttt{CLI} — запретить (IF = 0)
\item \texttt{STI} — разрешить (IF = 1)
\item Программирование маски в контроллере прерываний (IMR)
\end{itemize}

\subsubsection*{Вопрос 113. Какие прерывания можно запретить, какие нельзя?}

\begin{itemize}
\item \textbf{Можно запретить:} маскируемые аппаратные (INTR)
\item \textbf{Нельзя запретить:} NMI, исключения процессора, программные прерывания INT n
\end{itemize}

\subsubsection*{Вопрос 114. Почему при исключениях сохраняется адрес вызвавшей команды?}

Для возможности \textbf{повторного выполнения команды} после устранения причины исключения.

Пример: при Page Fault:
\begin{enumerate}
\item Сохраняется адрес команды, вызвавшей исключение
\item ОС загружает нужную страницу в память
\item Команда выполняется повторно
\end{enumerate}

\subsubsection*{Вопрос 115. Можно ли использовать JMP для точки останова?}

\textbf{Нет}, потому что:
\begin{itemize}
\item JMP занимает минимум 2 байта (короткий) или 5 байт (дальний)
\item JMP не сохраняет адрес возврата
\item JMP не вызывает прерывание для передачи управления отладчику
\end{itemize}

\subsubsection*{Вопрос 116. Что такое <<сигнал>> и <<информационный параметр сигнала>>?}

\textbf{Сигнал} — физическая величина (или процесс), несущая информацию.
Примеры: напряжение, ток, электромагнитная волна.

\textbf{Информационный параметр} — характеристика сигнала, кодирующая данные:
\begin{itemize}
\item Уровень напряжения (в цифровой логике)
\item Частота (в FM-модуляции)
\item Фаза (в PSK-модуляции)
\end{itemize}

\subsubsection*{Вопрос 117. Почему используют двухуровневое кодирование?}

\begin{itemize}
\item \textbf{Высокая помехоустойчивость} — два уровня легко различить
\item \textbf{Простота реализации} — два устойчивых состояния транзистора
\item \textbf{Надёжность} — большой запас между уровнями
\item \textbf{Совместимость с булевой алгеброй}
\end{itemize}

\subsubsection*{Вопрос 118. Как изображаются два значения двоичного разряда?}

\begin{itemize}
\item \textbf{Логический 0:} низкое напряжение (около 0 В, до $V_{OL}$)
\item \textbf{Логическая 1:} высокое напряжение (от $V_{OH}$ до $V_{CC}$)
\end{itemize}
Между уровнями — запрещённая зона для помехоустойчивости.

\subsubsection*{Вопрос 119. Простейшая электрическая цепь для формирования двухуровневого сигнала.}

\textbf{Инвертор (элемент НЕ)} на транзисторе с резистором подтяжки:
\begin{itemize}
\item Вход = 0: транзистор закрыт → выход = 1 (через резистор к $V_{CC}$)
\item Вход = 1: транзистор открыт → выход = 0 (через транзистор к земле)
\end{itemize}

\subsubsection*{Вопрос 120. Почему используют двунаправленные линии ввода-вывода?}

\begin{itemize}
\item \textbf{Экономия выводов} корпуса микроконтроллера
\item \textbf{Гибкость конфигурации} — один вывод может быть и входом, и выходом
\item \textbf{Поддержка двунаправленных протоколов} (I$^2$C)
\item \textbf{Адаптация под задачу} без изменения аппаратуры
\end{itemize}

\subsubsection*{Вопрос 121. Типовая регистровая модель подсистемы параллельного ввода-вывода.}

\begin{center}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Регистр} & \textbf{Название} & \textbf{Назначение} \\
\hline
DDR & Data Direction Register & Задаёт направление: 0=вход, 1=выход \\
\hline
PORT & Port Register & Значения для вывода (или подтяжка для входа) \\
\hline
PIN & Pin Register & Чтение текущего состояния выводов \\
\hline
\end{tabular}
\end{center}

\subsubsection*{Вопрос 122. Во сколько раз возрастёт производительность вычисления $(a+b)(b-c)(d+b)$ на Pentium по сравнению с i486?}

\textbf{Анализ:}
\begin{itemize}
\item Операции $(a+b)$, $(b-c)$, $(d+b)$ — \textbf{независимы}
\item Два умножения требуют результатов сложений
\end{itemize}

\textbf{Intel 80486:} один конвейер — все операции последовательно.

\textbf{Intel Pentium:} два конвейера (U и V) — суперскалярная архитектура:
\begin{itemize}
\item $(a+b)$ и $(b-c)$ — параллельно
\item $(d+b)$ — следующий такт
\item Умножения — с учётом зависимостей
\end{itemize}

\textbf{Ускорение: примерно в 1.5-2 раза}, но не более чем в 2 раза из-за:
\begin{itemize}
\item Ограничения двумя конвейерами
\item Зависимостей по данным между операциями
\item Не все пары команд могут выполняться параллельно
\end{itemize}